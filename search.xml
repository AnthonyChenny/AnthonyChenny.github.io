<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Datagrip快捷键总结]]></title>
    <url>%2F2019%2F03%2F04%2FRedis%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[redis的安装gcc的安装1yum install gcc-c++ 执行下面的指令,查看gcc版本1gcc -v 再次执行make指令,发现还是报错主要是jemalloc/jemalloc.h：没有那个文件或目录这个错误造成的.解决方法:运行1make distclean 然后继续执行make指令.安装完成后可以执行make install测试是否安装完成安装完成; 备份以及配置文件修改在/目录下创建myredis文件夹1mkdir nyredis 将/opt/redis-3.0.4/redis.conf文件备份到myredis下1cp redis.conf /myredis/ 修改conf文件1vim redis.conf 找到General下的配置shift+$ 到该行的最后面 按i修改为no ESC+:wq写入并退出 启动redis的服务注意不要使用原来的conf文件启动12redis-server /myredis/redis.conf//redis的默认安装路径在/usr/local/bin目录下 查看redis是否启动 1ps -ef|grep redis 杂项设置 redis的默认端口:6379 DBSiZE指令:选择一个库(select n),然后输入DBSIZE可以查看该库中的数据有多少个 FLUSHDB:清除该库中的数据 FLUSHALL:清除所有库中数据(慎重操作)五大数据类型 Redis键(key) keys *:查看所有的键 exists key的名字，判断某个key是否存在 move key db —&gt;当前库就没有了，被移除了 expire key 秒钟：为给定的key设置过期时间(当设置的时间过了之后,改key就从内存中删除了) ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期 type key 查看你的key是什么类型 redis字符串 set/get/del/append/strlen incr/decr/incrby/decrby,一定要是数字才能加减; 1234//下面列举一些简单的例子get k1 //输出:2incr k1 //输出:3;每次默认加1incrby k1 2 //输出:5; getrange和setrange,获取指定范围区间的值,和between…and…类似,需要注意的是,0到-1表示全部,列如: 1234567-- getrange --get k1 //输出:v1123456getrange k1 0 -1 //输出:v1123456getrange k1 0 2 //输出:v11-- setrange --get k1 //输出:v1123456setrange k1 1 XX //输出:vXX23456(表示从k1的第一位开始连续设置两位XX) setex(set with expire)键秒值/setnx(set if not exist)SETEX key seconds value:将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。setnx key value:只在键 key 不存在的情况下， 将键 key 的值设置为 value,如果key值已经存在,那么该指令不会做任何操作 mset/mget/msetnx:同时设置一个或多个 key-value 对123-- msetnx --keys * //输出:k1 k2 k3msetnx k3 v3 k4 v4 //执行结果返回0,执行不成功 Redis列表(List) lpush/rpush/lrange 123456-- lpush --lpush list0 1 2 3 4 5lrange list0 0 -1 //输出:5 4 3 2 1-- rpush --rpush list1 1 2 3 4 5lrange list1 0 -1 //输出:1 2 3 4 5 lpop/rpoplpop key:移除并返回列表的第一个元素。rpop key:移除并返回列表 key 的尾元素 12345-- lpop ---- rpop --lpush list0 1 2 3lpop list0 //输出:3rpop list0 //输出:1lrange list0 0 -1 //输出:2 lindex:按照索引下标获得元素(从上到下) 123--- lindex --lrange list0 0 -1 //输出:5 4 3 2 1lindex list0 1 //输出:4 llen lrem key删N个value(按照从上到下的顺序开始删除) 123-- lrem --lrange list0 0 -1 //输出:1 1 2 3 4 5lrem list0 1 2 //输出:1 1 3 4 5 ltrim key 开始index结束index,截取指定范围的值后再赋值给key 12345-- ltrim --lpush list0 1 1 2 2 3 3 4 4 5 5lrange list0 0 -1 //输出:5 5 4 4 3 3 2 2 1 1ltrim list0 2 4 //截取list0的2到4索引的数据并放入keylrange list0 0 -1 //输出: 4 4 3 rpoplpush源列表 目的列表 123456-- rpoplpush --lpush list0 1 2 3 4 5 6 lpush list1 7 8 9 0rpoplpush list0 list1lrange list0 0 -1 //输出:6 5 4 3 2 lrange list1 0 -1 //输出:1 0 9 8 7 lset key index value 1234lpush list0 1 2 3 4 5 6LRANGE list0 0 -1 //输出:6 5 4 3 2 1lset list0 2 X //将2索引位置上插入XLRANGE list0 0 -1 //6 5 X 4 3 2 1 linsert key brfore/after 值1 值2(将值2插入到key中值1的前面) 123lrange list0 0 -1 //输出: 6 5 4 X 3 2 1linsert list0 before X java //在x前面插入javalrange list0 0 -1 //输出: 6 5 4 java X 3 2 1 Redis集合(Set–无序无重复) sadd/smembers/sismember 123-- sadd --sadd set0 v1 v2 v3 v4 v5 v6smembers set0 //输出:v1 v2 v3 v4 v6 v5 scard,获取集合里面的元素个数 screm key value删除集合中的元素 srandmember key 某个整数(随机出几个数) 1234-- srandmember --sadd set0 1 2 3 4 5 6 srandmember set0 3 //从set0中随机取三个数输出: 2 3 5(随机取的) spop key :随机出栈 1spop set0 //这里出栈后set中就不存在了 smove key1 key2 在key1里的某个值 :作用是将key1里的某个值赋值给key2 123sadd set0 1 2 3 4 5 6smove set0 set1 1 //将set0中的1赋值给set1smembers set1 //输出:1 集合类 [ 差集:sdiff] [ 交集:sinter] [ 并集:sunion] Redis哈希(Hash)—类似JAVA中的Map&lt;String,Object&gt;() hset/hget/hmset/hmget/hgetall/hdel 123456hset user name zhangsan hmget user id 1 age 23hmget user id name age //输出:1 张三 23hgetall user //&quot;name&quot; &quot;zhangsan&quot; &quot;id&quot; &quot;1&quot; &quot;age&quot; &quot;23&quot;hkeys user //输出:id name agehvals user //输出:1 zhangsan 23 hlen hexists key 在key里面获取某个值的key hkeys/hvals hincrby/hincybyfloat hsetnx Redis有序集合Zset(sorted set) zadd/zrange/zrange withscores 12345zadd set01 60 v1 70 v2 80 v3 90 v4 100 v5zrange set01 0 -1 //输出:v1 v2 v3 v4 v5zrange set01 0 -1 withscores//输出:v1 60 v2 70 v3 80 v4 90 v5 100 zrangebyscore key 开始score 结束score 12zrangebyscore set01 60 90 //输出:v1 v2 v3 v4zrangebyscore set01 60 90 limit 2 2 //输出:v3 v4;筛选出set01中大于等于60小于等于90的从第二个开始的往后两条数据;这个有点类似mysql的分页查询 zrem key 某score下的对应的value的值,作用是删除某个元素 123zrange set01 0 -1 //输出:v1 v2 v3 v4 v5zrem set01 v1 zrange set01 0 -1 //输出:v2 v3 v4 v5 zcard/zcount key score区间/zrank key values值,作用是获得下标值/zscore key 对应值,获得分数 zrevrank key values值,作用是逆序获得下标值解析配置文件redis.conf volatile-lru: 使用LRU算法移除key,只对设置了过期时间的键 allkeys-lru:使用LRu算法移除key volatile-random: 在过期集合中移除随机的key,只对设置了过期时间的键 allkeys-random:移除随机的key volatile-ttl:移除哪些ttl值最小的key,即那些最近要过期的key noeviction:不进行移除.永不过期 redis常见配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273参数说明redis.conf 配置项说明如下：1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 63794. 绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12. 指定本地数据库存放目录 dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf Redis持久化(Redis Persistence) Redis DataBase(rdb) 什么是RDB:在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 Rdb保存的是dump.rdb文件 配置文件当你在执行shutdown等破坏指令的时候,redis会迅速将内存中的数据灌入dump.rdb;执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 Append Only File(aof) 什么是aof: 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 appendonly.aof文件和dump.rdb文件可以共存,先加载aof文件来恢复原始数据,但是如果appendonly.aof在生产环境中由于断电等一系列情况会出现一些不符合规范的sql,这时可以执行redis-check-aof –fix appendonly.aof修正 Redis的事务 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞 常用事务命令:下面列举一些常见的redis事务情况:(1). 正常执行(2). 放弃事务(3). 全体连坐(只要有一个出现了错误,整个事务都不会执行)(4). 冤头债主这里第三点和第四点要区分一下,第三点是在开始时就报错了,而第四点是在运行过程中出现了错误,只有出现错误的不会执行,其他的指令还会执行.举个栗子:java在写IO文件时会throws异常这个就类似第三点,java中10/0,在写这行代码时不会报错,但是编译运行会报错,这里是我的一点理解(5). watch监控乐观锁和悲观锁 Redis的发布和订阅进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 Redis的复制(Master/slave) 也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 配从(机)不配主(机) 从库配置:slaveof 主库ip 主库端口;每次从机与master断开之后,都需要重新连接,除非你配置进redis.conf文件 修改配置文件的细节操作 拷贝三个redis.conf文件 开启daemonize yes pid文件名字 指定端口 log文件名字 dump.rdb名字 一主二仆(一个主句挂两个从机)将三个机器配置完成后,下面来模拟一下主从复制,读写分离输入:info replication可以查看主从复制信息,一开始默认三台机器都是master.接下来讨论三种情况: 主机先设了几个值,之后两个从机再slaveof主机,之后主机再设值,那么从机能拿到slaveof之前的值吗?答案是可以的 读写分离,写的权利归属测试后发现,从机不能写入,只有主机可以 主机宕机后,从机的状态测试发现,主机宕机后,从机不会上位,主机回来后,依旧照旧. 从机宕机后,状态以及能否继续连上主机工作通过测试发现,从机宕机后需要重新连接才能照常工作 薪火相传上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力 反客为主使当前数据库停止与其他数据库的同步，转成主数据库SLAVEOF no one—slaveof 新主库IP 新主库端口 哨兵模式(sentinel)是什么:反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 配置哨兵模式: 在myredis文件夹下新建sentinel.conf文件夹(注意名字不要写错) 编辑sentinel.conf文件,插入:sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机 哨兵模式开启之后,来模拟一下,让主机6389的那台机子挂掉,然后会投票选举出新的主机(这会有延迟,需要等待),从机上位;还有一点需要注意,这时候如果原来的主机6379重新回来会变成slave从机,加入到这个系统中来]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Datagrip快捷键总结]]></title>
    <url>%2F2019%2F02%2F21%2FDatagrip%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Data Grip常用的快捷键总结: 管理数据库连接：Ctrl+Alt+Shift+S 文件视图窗口：Alt+2 进入一个文件：Ctrl+Shift+N 打开最近的文件：Ctrl+E 导航栏：Alt+Home 全局搜索：双击Shift Ctrl+Enter：执行选中的SQL语句 Ctrl+Shift+左右箭头：调整列宽度（选中行，可以调整所有列的宽度） Ctrl+Y：删除行 Ctrl+Delete：删除结尾单词 Ctrl+Backspace：删除开头单词 Ctrl+D：选择复制行 Ctrl+N：进入某个表（按name） Ctrl+G：进入行或列 Shift+f6: 变量重命名（弹出重命名对话框） Ctrl+Shift+U: 大小写自动转换（字段名或者表名） Ctrl+Shift+Enter: sql格式化（选中需要格式化的代码） *通配符自动展开：查询的时候我们会使用select *查询所有列，这是不太好的习惯，datagrip能快速展开列。光标定位到*后面，按下Alt+Enter快捷键]]></content>
      <tags>
        <tag>Datagrip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This blog is used for test!]]></title>
    <url>%2F2019%2F02%2F14%2FThis%20blog%20is%20used%20for%20test%2F</url>
    <content type="text"><![CDATA[这篇博客主要用于一些插件和一些代码的测试 网易云音乐测试 内置标签测试 文本居中测试使用方式: HTML方式：使用这种方式时，给 img 添加属性 class=”blockquote-center” 即可。 标签方式：使用 centerquote 或者 简写 cq。123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; html测试标签测试 标签别名]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
